<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/docs/swagger.yaml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/swagger.yaml" />
              <option name="updatedContent" value="openapi: 3.0.3&#10;info:&#10;  title: Local File Storage API&#10;  version: 1.0.0&#10;  description: API for uploading and retrieving image files from local storage&#10;servers:&#10;  - url: http://localhost:8080&#10;paths:&#10;  /files/upload:&#10;    post:&#10;      summary: Upload an image file&#10;      requestBody:&#10;        required: true&#10;        content:&#10;          multipart/form-data:&#10;            schema:&#10;              type: object&#10;              properties:&#10;                file:&#10;                  type: string&#10;                  format: binary&#10;      responses:&#10;        '200':&#10;          description: File uploaded successfully&#10;          content:&#10;            application/json:&#10;              schema:&#10;                type: object&#10;                properties:&#10;                  message:&#10;                    type: string&#10;                  filename:&#10;                    type: string&#10;        '400':&#10;          description: No file is received&#10;        '500':&#10;          description: Failed to save file&#10;  /files/{filename}:&#10;    get:&#10;      summary: Retrieve an image file by filename&#10;      parameters:&#10;        - in: path&#10;          name: filename&#10;          required: true&#10;          schema:&#10;            type: string&#10;      responses:&#10;        '200':&#10;          description: File retrieved successfully&#10;          content:&#10;            image/jpeg: {}&#10;            image/png: {}&#10;            image/gif: {}&#10;            application/octet-stream: {}&#10;        '404':&#10;          description: File not found&#10;        '500':&#10;          description: Failed to retrieve file&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/infrastructure/persistence/repositories/account_repositoy_impl.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/infrastructure/persistence/repositories/account_repositoy_impl.go" />
              <option name="originalContent" value="package repositories&#10;&#10;import (&#10;&#9;&quot;AuthService/internal/domain/entities&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;type AccountRepository struct {&#10;&#9;db *gorm.DB&#10;}&#10;&#10;func (a AccountRepository) FindAll() ([]T, error) {&#10;&#9;//TODO implement me&#10;&#9;panic(&quot;implement me&quot;)&#10;}&#10;&#10;func (a AccountRepository) FindByID(id any) (T, error) {&#10;&#9;//TODO implement me&#10;&#9;panic(&quot;implement me&quot;)&#10;}&#10;&#10;func (a AccountRepository) Create(entity T) (T, error) {&#10;&#9;//TODO implement me&#10;&#9;panic(&quot;implement me&quot;)&#10;}&#10;&#10;func (a AccountRepository) Update(entity T) (T, error) {&#10;&#9;//TODO implement me&#10;&#9;panic(&quot;implement me&quot;)&#10;}&#10;&#10;func (a AccountRepository) Delete(id any) error {&#10;&#9;//TODO implement me&#10;&#9;panic(&quot;implement me&quot;)&#10;}&#10;&#10;func (a *AccountRepositoryImpl) FindAll() ([]*entities.Account, error) {&#10;&#9;var accounts []*entities.Account&#10;&#9;if err := a.db.Find(&amp;accounts).Error; err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return accounts, nil&#10;}&#10;&#10;func (a *AccountRepositoryImpl) FindByEmail(email string) (*entities.Account, error) {&#10;&#9;var account entities.Account&#10;&#9;if err := a.db.Where(&quot;email = ?&quot;, email).First(&amp;account).Error; err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return &amp;account, nil&#10;}&#10;&#10;func (a *AccountRepositoryImpl) FindByUsername(username string) (*entities.Account, error) {&#10;&#9;// Username field does not exist in Account entity, so this should be implemented if you have a username field or join with User entity.&#10;&#9;return nil, gorm.ErrRecordNotFound&#10;}&#10;" />
              <option name="updatedContent" value="package repositories&#10;&#10;import (&#10;&#9;&quot;AuthService/internal/domain/entities&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;type AccountRepositoryImpl struct {&#10;&#9;db *gorm.DB&#10;}&#10;&#10;// Custom methods for Account&#10;func (a *AccountRepositoryImpl) FindAll() ([]*entities.Account, error) {&#10;&#9;var accounts []*entities.Account&#10;&#9;if err := a.db.Find(&amp;accounts).Error; err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return accounts, nil&#10;}&#10;&#10;func (a *AccountRepositoryImpl) FindByEmail(email string) (*entities.Account, error) {&#10;&#9;var account entities.Account&#10;&#9;if err := a.db.Where(&quot;email = ?&quot;, email).First(&amp;account).Error; err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return &amp;account, nil&#10;}&#10;&#10;func (a *AccountRepositoryImpl) FindByUsername(username string) (*entities.Account, error) {&#10;&#9;// Username field does not exist in Account entity, so this should be implemented if you have a username field or join with User entity.&#10;&#9;return nil, gorm.ErrRecordNotFound&#10;}&#10;&#10;// You can add more custom methods here as needed&#10;&#10;func NewAccountRepository(db *gorm.DB) *AccountRepositoryImpl {&#10;&#9;return &amp;AccountRepositoryImpl{db: db}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/infrastructure/service/auth_service_impl.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/infrastructure/service/auth_service_impl.go" />
              <option name="originalContent" value="package service&#10;&#10;import (&#10;&#9;&quot;AuthService/internal/application/interfaces&quot;&#10;&#9;&quot;AuthService/internal/application/services&quot;&#10;&#9;&quot;AuthService/internal/domain/entities&quot;&#10;&#9;&quot;AuthService/pkg/logger&quot;&#10;&#9;&quot;context&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;type authServiceImpl struct {&#10;&#9;accountGen interfaces.GenericRepository[entities.Account]&#10;&#9;db         *gorm.DB&#10;}&#10;&#10;func NewAuthService(db *gorm.DB, accountGen interfaces.GenericRepository[entities.Account]) services.AuthService {&#10;&#9;return &amp;authServiceImpl{&#10;&#9;&#9;db:         db,&#10;&#9;&#9;accountGen: accountGen,&#10;&#9;}&#10;}&#10;&#10;func (a *authServiceImpl) GetAllAccounts() ([]entities.Account, error) {&#10;&#9;ctx := context.Background()&#10;&#9;accounts, _, err := a.accountGen.GetAll(ctx, nil, nil, 0, 0)&#10;&#9;if err != nil {&#10;&#9;&#9;log := logger.GetLogger()&#10;&#9;&#9;log.Error(&quot;Error fetching accounts: &quot; + err.Error())&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return accounts, nil&#10;}&#10;&#10;func (a *authServiceImpl) Login(username, password string) (*entities.Account, error) {&#10;&#9;// Assuming username is email&#10;&#9;//account, err := a.db.FindByEmail(username)&#10;&#9;//if err != nil {&#10;&#9;//&#9;return nil, err&#10;&#9;//}&#10;&#9;//// TODO: Replace with real password hash check&#10;&#9;//if account.PasswordHash != password {&#10;&#9;//&#9;return nil, errors.New(&quot;invalid credentials&quot;)&#10;&#9;//}&#10;&#9;return nil, nil&#10;}&#10;&#10;func (a *authServiceImpl) CreateAccount(account *entities.Account) (*entities.Account, error) {&#10;&#9;// You may want to hash the password here&#10;&#9;// TODO: Add password hashing&#10;&#9;//created, err := a.accountRepo.Save(account)&#10;&#9;//if err != nil {&#10;&#9;//&#9;return nil, err&#10;&#9;//}&#10;&#9;//return created, nil&#10;&#9;panic(&quot;not implemented&quot;)&#10;}&#10;" />
              <option name="updatedContent" value="package service&#10;&#10;import (&#10;&#9;&quot;AuthService/internal/application/interfaces&quot;&#10;&#9;&quot;AuthService/internal/application/services&quot;&#10;&#9;&quot;AuthService/internal/domain/entities&quot;&#10;&#9;&quot;AuthService/pkg/logger&quot;&#10;&#9;&quot;context&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;&#9;&quot;golang.org/x/crypto/bcrypt&quot;&#10;)&#10;&#10;type authServiceImpl struct {&#10;&#9;accountGen interfaces.GenericRepository[entities.Account]&#10;&#9;db         *gorm.DB&#10;}&#10;&#10;func NewAuthService(db *gorm.DB, accountGen interfaces.GenericRepository[entities.Account]) services.AuthService {&#10;&#9;return &amp;authServiceImpl{&#10;&#9;&#9;db:         db,&#10;&#9;&#9;accountGen: accountGen,&#10;&#9;}&#10;}&#10;&#10;func (a *authServiceImpl) GetAllAccounts() ([]entities.Account, error) {&#10;&#9;ctx := context.Background()&#10;&#9;accounts, _, err := a.accountGen.GetAll(ctx, nil, nil, 0, 0)&#10;&#9;if err != nil {&#10;&#9;&#9;log := logger.GetLogger()&#10;&#9;&#9;log.Error(&quot;Error fetching accounts: &quot; + err.Error())&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return accounts, nil&#10;}&#10;&#10;func (a *authServiceImpl) Login(username, password string) (*entities.Account, error) {&#10;&#9;// Assuming username is email&#10;&#9;var account entities.Account&#10;&#9;err := a.db.Where(&quot;email = ?&quot;, username).First(&amp;account).Error&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;// Compare hashed password&#10;&#9;if err := bcrypt.CompareHashAndPassword([]byte(account.PasswordHash), []byte(password)); err != nil {&#10;&#9;&#9;return nil, errors.New(&quot;invalid credentials&quot;)&#10;&#9;}&#10;&#9;return &amp;account, nil&#10;}&#10;&#10;func (a *authServiceImpl) CreateAccount(account *entities.Account) (*entities.Account, error) {&#10;&#9;// Hash the password before saving&#10;&#9;hash, err := bcrypt.GenerateFromPassword([]byte(account.PasswordHash), bcrypt.DefaultCost)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;account.PasswordHash = string(hash)&#10;&#9;if err := a.db.Create(account).Error; err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return account, nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>